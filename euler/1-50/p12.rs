//!
//! The sequence of triangle numbers is generated by adding the natural numbers.
//! So the $7^{th}$ triangle number would be $1 + 2 + 3 + 4 + 5 + 6 + 7 = 28$.
//! The first ten terms would be:
//!   $$1, 3, 6, 10, 15, 21, 28, 36, 45, 55, \cdots$$
//!
//! Let us list the factors of the first seven triangle numbers:
//!
//!   ```
//!    1: 1
//!    3: 1,3
//!    6: 1,2,3,6
//!   10: 1,2,5,10
//!   15: 1,3,5,15
//!   21: 1,3,7,21
//!   28: 1,2,4,7,14,28
//!   ```
//! We can see that 28 is the first triangle number to have over five divisors.
//!
//! What is the value of the first triangle number to have over five hundred
//! divisors?
//!
//! @see https://projecteuler.net/problem=12
//!
//! # 题目描述
//! 找到第一个含有超过 500 个因数的三角形数
//!
//! # 题解
//! 因为第 $n$ 个三角形数为 $\displaystyle f(n) = \frac{n \times (n+1)}{2}$, 而 $n$
//! 和 $n+1$ 互质，不妨假设 $n \equiv 0 \mod 2$, 故 $f(n)$ 的因数个数为
//! $\displaystyle \frac{n}{2}$ 的因数个数乘以 $n+1$ 的因数个数。
//! 故将 $n$ 分解为 $\displaystyle e_1^{p_1} \cdot e_2^{p_2} \cdots e_x^{p_x}$,
//! $n+1$ 分解为 $\displaystyle e_{x+1}^{p_{x+1}} \cdot e_{x+2}^{p_{x+2}} \cdots e_y^{p_y}$,
//! 则 $f(n)$ 的因数个数为
//!
//!   \begin{align*}
//!     \left\lbrace
//!       \begin{aligned}
//!         &(p_1-1) \cdot p_2 \cdots p_y, &n \equiv 0 \mod 2\\\\
//!         &p_1 \cdot p_2 \cdots (p_x-1) \cdot p_{x+1} \cdots p_y, &n \equiv 1 \mod 2\\\\
//!       \end{aligned}
//!     \right.
//!   \end{align*}
//!
//! # 答案
//! 76576500
//!
fn main() {
  let mut answer = 0;
  for x in 500.. {
    let x_factors = prime_factorization(x);
    let y_factors = prime_factorization(x + 1);
    let x_fac_total = x_factors.iter()
      .map(|p: &PrimeFactor| -> usize {
        if p.prime == 2 {
          p.exponential
        } else {
          p.exponential + 1
        }
      })
      .fold(1usize, |acc, p| acc * p)
      ;
    let y_fac_total = y_factors.iter()
      .map(|p: &PrimeFactor| -> usize {
        if p.prime == 2 {
          p.exponential
        } else {
          p.exponential + 1
        }
      })
      .fold(1usize, |acc, p| acc * p)
      ;
    let total = x_fac_total * y_fac_total;
    if total >= 500 {
      answer = x * (x + 1) / 2;
      break;
    }
  }
  println!("{:?}", answer)
}


#[derive(Debug)]
struct PrimeFactor {
  prime: i32,
  exponential: usize,
}


fn prime_factorization(mut n: i32) -> Vec<PrimeFactor> {
  let mut ret: Vec<PrimeFactor> = vec![];
  let square_root_of_n: i32 = (n as f32).sqrt().ceil() as i32 + 1;
  for x in 2..square_root_of_n {
    let mut exponential = 0;
    while n % x == 0 {
      exponential += 1;
      n /= x;
    }
    if exponential > 0 {
      let factor = PrimeFactor {
        prime: x,
        exponential: exponential,
      };
      ret.push(factor);
    }
  }
  return ret;
}
